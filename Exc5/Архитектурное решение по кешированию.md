# Кеширование

## Мотивация

Внедрение кеширования необходимо для решения следующих проблем:

* **снижение нагрузки на БД**: уменьшение количества запросов к базам данных за счёт хранения часто запрашиваемых данных
* **ускорение отклика системы**: улучшение времени отклика API, особенно для пользователей во время пиковых нагрузок
* **повышение стабильности**: предотвращение сбоев и задержек в критических точках системы

**Ключевые точки для кеширования**:
* `Shop API`: кеширование каталога товаров для улучшения пользовательского опыта и быстрого доступа к данным
* `MES API`: кеширование результатов расчёта стоимости, чтобы избежать повторных сложных вычислений
* `MES API`: кеширование данных о последних заказах для мгновенного предоставления информации операторам

## Предлагаемое решение

### Кеширование каталога товаров в shop API

#### Подход к кешированию данных

Внедрим серверное кеширование:
* каталог товаров может быть большим и изменяться нечасто, сервер сможет централизованно управлять обновлением данных и их консистентностью
* разные клиенты могут использовать одну и ту же кешированную копию данных

#### Паттерн кеширования

В качестве паттерна кеширования будем использовать `Cache-Aside`: каталог данных очень часто читается и очень редко обновляется

#### Анализ альтернативных подходов к кешированию
 
* `Write-Through` подходит для сценариев с частыми записями: в каталоге преобладают операции чтения
* `Refresh-Ahead` подходит для сценариев с большим количеством операций чтения, но так как каталог меняется так редко, мы получим обновления кеша без реальной необходимости.

#### Запрос товаров из каталога

![c4](resources/getcataloguepage.png)

#### Стратегия инвалидации кеша

Доработаем систему так, при добавлении/изменении/удалении карточки товара в каталоге, в системе будут генерироваться соответствующие события и складываться в Kafka. 
Создадим консьмюер, который будет реагировать на эти события и актуализировать кеш каталога.

Для каких-то внештатных ситуаций, когда нужно срочно полностью перезаполнить каталог, мы создадим endpoint, который очистит кеш, чтобы он наполнился заново при следующем запросе к каталогу.













