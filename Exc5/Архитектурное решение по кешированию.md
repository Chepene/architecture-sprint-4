# Кеширование

## Мотивация

Внедрение кеширования необходимо для решения следующих проблем:

* **снижение нагрузки на БД**: уменьшение количества запросов к базам данных за счёт хранения часто запрашиваемых данных
* **ускорение отклика системы**: улучшение времени отклика API, особенно для пользователей во время пиковых нагрузок
* **повышение стабильности**: предотвращение сбоев и задержек в критических точках системы

**Ключевые точки для кеширования**:
* `Shop API`: кеширование каталога товаров для улучшения пользовательского опыта и быстрого доступа к данным
* `MES API`: кеширование результатов расчёта стоимости, чтобы избежать повторных сложных вычислений
* `MES API`: кеширование данных о последних заказах для мгновенного предоставления информации операторам

## Предлагаемое решение

### Кеширование каталога товаров в shop API

#### Подход к кешированию данных

Внедрим серверное кеширование:
* каталог товаров может быть большим и изменяться нечасто, сервер сможет централизованно управлять обновлением данных и их консистентностью
* разные клиенты могут использовать одну и ту же кешированную копию данных

#### Паттерн кеширования

В качестве паттерна кеширования будем использовать `Cache-Aside`: каталог данных очень часто читается и очень редко обновляется

#### Анализ альтернативных подходов к кешированию
 
* `Write-Through` подходит для сценариев с частыми записями: в каталоге преобладают операции чтения
* `Refresh-Ahead` подходит для сценариев с большим количеством операций чтения, но так как каталог меняется так редко, мы получим обновления кеша без реальной необходимости.

#### Запрос товаров из каталога

![c4](resources/getcataloguepage.png)

#### Стратегия инвалидации кеша

Стратегия: Инвалидация на основе изменений

Доработаем систему так, при добавлении/изменении/удалении карточки товара в каталоге, в системе будут генерироваться соответствующие события и складываться в Kafka. 
Создадим консьмюер, который будет реагировать на эти события и актуализировать кеш каталога.

Для каких-то внештатных ситуаций, когда нужно срочно полностью перезаполнить каталог, мы создадим endpoint, который очистит кеш, чтобы он наполнился заново при следующем запросе к каталогу.

| Временная инвалидация                                                                                | Инвалидация, основанная на запросах              | Инвалидация на основе изменений                                                                              | Программная инвалидация                                                                                        | Инвалидация по ключу                                                                                                                 |
|------------------------------------------------------------------------------------------------------|--------------------------------------------------|--------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| Неоптимальна: из-за редких изменений большинство обновлений кеша будет происходить без необходимости | Не подходит, потому что мы кешируем весь каталог| Неоптимально: из-за точечных изменений нет смысла полностью обновлять кеш каталога при каждом изменении | Можно использовать, но в нашем случае простые условия инвалидации не требуют сложных программных подходов | Оптимальна: изменения в каталоге редки и можно обновлять только изменённые или добавленные товары, избегая лишних операций |









